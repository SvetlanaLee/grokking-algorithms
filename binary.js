// У вас есть книжная полка, у каждой книги есть размер - количество страниц. 
// Книжная полка представлена массивом, в котором хранятся размеры книг в порядке возрастания. 
// Вам надо написать функцию, которая принимала бы этот массив размеров текущих книг, 
// размер новой книги и вычисляла бы количество больших по размеру книг уже на полке. 
// Требуемая алгоритмическая сложность: время O(log2n).
// Реализуйте алгоритм бинарного поиска. 
// С его помощью вы найдёте место в массиве, где слева от него будут элементы меньше или равны, а справа строго больше.
// Обратите внимание на случай когда у нас на полке есть несколько книг с тем же размером, что и у новой книги. 
// Именно поэтому мы не останавливаем бинарный поиск когда найдём какой-то из таких размеров в массиве, 
// ведь для ответа нам важно чтобы справа от найденной позиции были книги только строго большие по размеру.

const arr = [90, 130, 130, 145, 168, 280, 286, 290, 300, 300, 300, 305, 400, 410, 500, 501];

const pages = 296;

function binarySearch (arr, pages) {
  let start = 0;
  let end = arr.length - 1;
  let result = 0;

  if (pages < arr[start]) {
    return result = arr.length
  }
  
  while (start <= end) {
    let newPlace = Math.floor((start + end) / 2);
    
    if (pages >= arr[newPlace] && pages < arr[newPlace + 1]) {
      return result = arr.length - (newPlace + 1)
    } else if (arr[newPlace] <= pages) {
      start = newPlace + 1;
    } else if (arr[newPlace] > pages) {
      end = newPlace - 1;
    } else {
      return result = 0
    }
  }

  return result
}


console.log(binarySearch(arr, pages))
